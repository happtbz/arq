package main

//go:generate go run ./generator.go

import (
	"context"
	"encoding/json"
	"fmt"
	"html/template"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"

	devices "github.com/src-doo/go-devicetype-library/pkg"
)

const (
	githubRepoURL    = "https://github.com/netbox-community/devicetype-library.git"
	shaCommitFile    = "../../sha.txt"
	manufacturerDir  = "../../pkg/"
	combinedFile     = "../../pkg/combined_data.go"
	githubRepo       = "devicetype-library"
	cloneDir         = "/tmp/" + githubRepo
	githubRepoSubdir = "device-types"
	githubOwner      = "netbox-community"
	branch           = "master"
)

const manufacturerTemplate = `// Code generated by go generate; DO NOT EDIT.
package devices

var DeviceTypesMap{{ .Manufacturer }} = map[string]*DeviceData{
{{- range $model, $data := .Devices }}
    "{{ $model }}": {
        Manufacturer: "{{ $data.Manufacturer }}",
        Model: "{{ $data.Model }}",
        Slug: "{{ $data.Slug }}",
        UHeight: {{ $data.UHeight }},
        PartNumber: "{{ $data.PartNumber }}",
        IsFullDepth: {{ $data.IsFullDepth }},
        Airflow: "{{ $data.Airflow }}",
        FrontImage: {{ $data.FrontImage }},
        RearImage: {{ $data.RearImage }},
        SubdeviceRole: "{{ $data.SubdeviceRole }}",
        Weight: {{ $data.Weight }},
        WeightUnit: "{{ $data.WeightUnit }}",
        IsPowered: {{ $data.IsPowered }},
        ConsolePorts: []ConsolePort{
            {{- range $data.ConsolePorts }}
            { Name: "{{ .Name }}", Type: "{{ .Type }}", Label: "{{ .Label }}", Poe: {{ .Poe }} },
            {{- end }}
        },
        ConsoleServerPorts: []ConsoleServerPort{
            {{- range $data.ConsoleServerPorts }}
            { Name: "{{ .Name }}", Type: "{{ .Type }}", Label: "{{ .Label }}" },
            {{- end }}
        },
        PowerPorts: []PowerPort{
            {{- range $data.PowerPorts }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Type: "{{ .Type }}", MaximumDraw: {{ .MaximumDraw }}, AllocatedDraw: {{ .AllocatedDraw }} },
            {{- end }}
        },
        PowerOutlets: []PowerOutlet{
            {{- range $data.PowerOutlets }}
            { Name: "{{ .Name }}", Type: "{{ .Type }}", Label: "{{ .Label }}", PowerPort: "{{ .PowerPort }}", FeedLeg: "{{ .FeedLeg }}", MaximumDraw: {{ .MaximumDraw }}, AllocatedDraw: {{ .AllocatedDraw }} },
            {{- end }}
        },
        FrontPorts: []FrontPort{
            {{- range $data.FrontPorts }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Type: "{{ .Type }}", RearPort: "{{ .RearPort }}", RearPortPosition: {{ .RearPortPosition }} },
            {{- end }}
        },
        RearPorts: []RearPort{
            {{- range $data.RearPorts }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Type: "{{ .Type }}", Positions: {{ .Positions }}, Poe: {{ .Poe }} },
            {{- end }}
        },
        ModuleBays: []ModuleBay{
            {{- range $data.ModuleBays }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Position: "{{ .Position }}" },
            {{- end }}
        },
			  DeviceBays: []DeviceBay{
				{{- range $data.DeviceBays }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}" },
            {{- end }}
        },
        InventoryItems: []InventoryItem{
            {{- range $data.InventoryItems }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Manufacturer: "{{ .Manufacturer }}", PartID: "{{ .PartID }}" },
            {{- end }}
        },
        Interfaces: []Interface{
            {{- range $data.Interfaces }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Type: "{{ .Type }}", MgmtOnly: {{ .MgmtOnly }} },
            {{- end }}
        },
    },
{{- end }}
}
`

const combinedTemplate = `// Code generated by go generate; DO NOT EDIT.
package devices

var DeviceTypesMap = map[string]map[string]*DeviceData{
{{- range $index, $Manufacturer := .Manufacturers }}
    "{{ $Manufacturer }}": DeviceTypesMap{{ index $.ManufacturersTrimmed $index }},
{{- end }}
}
`

type LatestCommitSHAResponse struct {
	SHA string `json:"sha"`
}

// Function that fetches and returns the latest commit sha from
// github.com/netbox-community/devicetype-library.
func getLatestCommitSHA(
	ctx context.Context,
	owner string,
	repo string,
	branch string,
) (string, error) {
	req, err := http.NewRequestWithContext(
		ctx,
		http.MethodGet,
		fmt.Sprintf("https://api.github.com/repos/%s/%s/commits/%s", owner, repo, branch),
		nil,
	)
	if err != nil {
		return "", fmt.Errorf("new request with context: %s", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", os.Getenv("GITHUB_API_TOKEN")))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("default client do: %s", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("resp.StatusCode: %d", resp.StatusCode)
	}

	var latestCommitSHAResp LatestCommitSHAResponse
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("read all: %s", err)
	}

	err = json.Unmarshal(body, &latestCommitSHAResp)
	if err != nil {
		return "", fmt.Errorf("unmarshal: %s", err)
	}

	return latestCommitSHAResp.SHA, nil
}

// writeSHAToFile writes SHA of commit to a file named filename.
func writeSHAToFile(sha, filename string) error {
	err := os.WriteFile(filename, []byte(sha), 0644) //nolint:gosec,mnd
	if err != nil {
		return fmt.Errorf("Failed to write to file: %v", err)
	}
	return nil
}

// Function that reads SHA of commit from a file named filename.
func readSHAFromFile(filename string) (string, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return "", fmt.Errorf("Failed to read file: %v", err)
	}
	return string(data), nil
}

func createManufacturerTemplate(
	manufacturer string,
	deviceData map[string]*devices.DeviceData,
) error {
	manufacturerTrimmed := trimManufacturer(manufacturer)
	filepath := filepath.Join(manufacturerDir, fmt.Sprintf("data_%s.go", manufacturerTrimmed))
	file, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("Failed to create file: %v", err)
	}
	defer file.Close()

	data := struct {
		Manufacturer string
		Devices      map[string]*devices.DeviceData
	}{
		Manufacturer: manufacturerTrimmed,
		Devices:      deviceData,
	}

	tmpl, err := template.New("manufacturerTemplate").Parse(manufacturerTemplate)
	if err != nil {
		return fmt.Errorf("Failed to parse template: %v", err)
	}

	err = tmpl.Execute(file, data)
	if err != nil {
		return fmt.Errorf("Failed to execute template: %v", err)
	}
	return nil
}

// Function that trims Manufacturer into a name that can be used as a golang variable name.
func trimManufacturer(manufacturer string) string {
	manufacturer = strings.ReplaceAll(manufacturer, " ", "_")
	manufacturer = strings.ReplaceAll(manufacturer, "-", "_")
	manufacturer = strings.ReplaceAll(manufacturer, "&", "")
	manufacturer = strings.ToLower(manufacturer)
	return manufacturer
}

func createCombinedTemplate(manufacturersOriginal []string, manufacturersTrimmed []string) error {
	file, err := os.Create(combinedFile)
	if err != nil {
		return fmt.Errorf("Failed to create file: %v", err)
	}
	defer file.Close()

	data := struct {
		Manufacturers        []string
		ManufacturersTrimmed []string
	}{
		Manufacturers:        manufacturersOriginal,
		ManufacturersTrimmed: manufacturersTrimmed,
	}

	tmpl, err := template.New("combinedTemplate").Parse(combinedTemplate)
	if err != nil {
		return fmt.Errorf("Failed to parse template: %v", err)
	}

	err = tmpl.Execute(file, data)
	if err != nil {
		return fmt.Errorf("Failed to execute template: %v", err)
	}
	return nil
}

func run() error {
	ctx := context.Background()
	defer ctx.Done()

	// Compare commit SHAs from last generated with the newest
	lastCommitSHA, err := readSHAFromFile(shaCommitFile)
	if err != nil {
		return fmt.Errorf("read SHA from file: %s", err)
	}
	currentCommitSHA, err := getLatestCommitSHA(ctx, githubOwner, githubRepo, branch)
	if err != nil {
		return fmt.Errorf("get latest commit SHA: %s", err)
	}

	if lastCommitSHA == currentCommitSHA {
		fmt.Printf(
			"github.com/%s/%s latest commit is %s. It is the same as last sync, skipping...",
			githubOwner,
			githubRepo,
			currentCommitSHA,
		)
		return nil
	}
	fmt.Printf(
		"New commit found. Last commit: %s, Current commit: %s\n",
		lastCommitSHA,
		currentCommitSHA,
	)

	// Clone the repository with depth 1 and master branch.
	err = cloneRepo(githubRepoURL, branch, cloneDir)
	if err != nil {
		return fmt.Errorf("clone repo: %s", err)
	}

	// Go through all of the files in the cloned repo and store them in a
	// map called manufacturer2deviceType2deviceData.
	manufacturer2deviceType2deviceData, manufacturers, manufacturersTrimmed, err := processClonedRepo(
		cloneDir,
	)
	if err != nil {
		return fmt.Errorf("process cloned repo: %s", err)
	}

	// Generate manufacturer files
	for manufacturer, deviceData := range manufacturer2deviceType2deviceData {
		err = createManufacturerTemplate(manufacturer, deviceData)
		if err != nil {
			return fmt.Errorf("create manufacturer template: %s", err)
		}
	}

	// Generate combined file
	err = createCombinedTemplate(manufacturers, manufacturersTrimmed)
	if err != nil {
		return fmt.Errorf("create combined template: %s", err)
	}

	// Update SHA file for last commit that was synced successfully
	if err = writeSHAToFile(currentCommitSHA, shaCommitFile); err != nil {
		return fmt.Errorf("write SHA to file: %s", err)
	}

	// Print general information
	for manufacturer, deviceData := range manufacturer2deviceType2deviceData {
		fmt.Printf(
			"Successfully collected %d device types for manufacturer %s\n",
			len(deviceData),
			manufacturer,
		)
	}
	return nil
}

func cloneRepo(repoURL, branch, cloneDir string) error {
	// Remove the directory if it exists
	if _, err := os.Stat(cloneDir); !os.IsNotExist(err) {
		if err := os.RemoveAll(cloneDir); err != nil {
			return fmt.Errorf("failed to remove existing clone directory: %w", err)
		}
	}

	// Clone the repository
	cmd := exec.Command("git", "clone", "--depth", "1", "-b", branch, repoURL, cloneDir)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	fmt.Printf("Cloning repository %s to %s\n", repoURL, cloneDir)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to clone repository: %w", err)
	}
	return nil
}

func processClonedRepo(
	cloneDir string,
) (map[string]map[string]*devices.DeviceData, []string, []string, error) {
	manufacturers := []string{}
	manufacturersTrimmed := []string{}
	manufacturer2deviceType2deviceData := map[string]map[string]*devices.DeviceData{}

	err := filepath.Walk(
		cloneDir+"/"+githubRepoSubdir,
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			// Skip directories
			if info.IsDir() {
				return nil
			}

			// Process YAML files
			if strings.HasSuffix(info.Name(), ".yml") || strings.HasSuffix(info.Name(), ".yaml") {
				dir := filepath.Dir(path)
				manufacturer := filepath.Base(dir)

				content, err := os.ReadFile(path)
				if err != nil {
					return fmt.Errorf("failed to read file %s: %w", path, err)
				}

				var obj devices.DeviceData
				if err := yaml.Unmarshal(content, &obj); err != nil {
					return fmt.Errorf("failed to unmarshal YAML from %s: %w", path, err)
				}

				manufacturerTrimmed := trimManufacturer(manufacturer)
				if _, exists := manufacturer2deviceType2deviceData[manufacturer]; !exists {
					manufacturer2deviceType2deviceData[manufacturer] = make(
						map[string]*devices.DeviceData,
					)
					manufacturers = append(manufacturers, manufacturer)
					manufacturersTrimmed = append(manufacturersTrimmed, manufacturerTrimmed)
				}

				manufacturer2deviceType2deviceData[manufacturer][obj.Model] = &obj
			}

			return nil
		},
	)

	if err != nil {
		return nil, nil, nil, err
	}

	return manufacturer2deviceType2deviceData, manufacturers, manufacturersTrimmed, nil
}

func main() {
	if err := run(); err != nil {
		log.Fatalf("%v", err)
	}
}
